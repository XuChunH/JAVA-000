1. 串行
在内存小的情况下，效率较高，内存大的时候，效果会越来越差. 

只有一个线程gc, 而且还是 stop the world 的, 内存大的时候性能会差

2. 并行 GC

并行 GC 是利用多个线程去做 gc，这样可以提高系统的吞吐，但是 gc 的时候, 会 stop the world

是java8默认的策略

3. CMS

CMS 主要是采用并发的策略, 尽量少的去影响业务，这样尽可能保证系统的响应时间。

由于业务线程和gc可以同时执行, 就会占用系统的资源，导致吞吐的下降. 而且还需要考虑触发gc的阈值，如果剩余的内存不足了, 会引起 `current mode failure`

由于需要标记，导致在大内存下的性能下降.

还存在碎片化的问题.

4. G1

G1 主要是为了解决大内存下的问题，尽可能的降低 gc 的影响。

G1 提供了 "软实时" 的功能，可以指定垃圾回收的时间，G1 会努力做到这个标准


# 总结
1. 各个垃圾回收器各有特点, 需要根据系统的特点、机器的配置等去配置

2. 不管选择哪个垃圾回收器, 参数的调优是一直需要进行的，因为不同的时间点, 系统体现出来的特点不一定相同, 这个时候需要调整参数, 甚至是更换垃圾回收器
